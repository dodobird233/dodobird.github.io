



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="呆呆鸟のBlog" href="http://dodobird.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="呆呆鸟のBlog" href="http://dodobird.top/atom.xml" />
<link rel="alternate" type="application/json" title="呆呆鸟のBlog" href="http://dodobird.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://dodobird.top/2023/05/11/assembly/">



  <title>
汇编语言实验 |
DodoBird's Blog = 呆呆鸟のBlog</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">汇编语言实验
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-05-11 11:00:09">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-05-11T11:00:09+08:00">2023-05-11</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">DodoBird's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://web-demo1-tlias.oss-cn-shanghai.aliyuncs.com/1.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://dodobird.top/2023/05/11/assembly/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="dodobird">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="呆呆鸟のBlog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="一-程序设计的全程实践"><a class="markdownIt-Anchor" href="#一-程序设计的全程实践">#</a> <strong>一、程序设计的全程实践</strong></h1>
<h2 id="11目的与要求"><a class="markdownIt-Anchor" href="#11目的与要求">#</a> <strong>1</strong>**.1**** 目的与要求 **</h2>
<p>1. 掌握汇编语言程序设计的全周期、全流程的基本方法与技术；</p>
<p>2. 通过程序调试、数据记录和分析，了解影响设计目标和技术方案的多种因素。</p>
<h2 id="12实验内容"><a class="markdownIt-Anchor" href="#12实验内容">#</a> <strong>1</strong>**.2**** 实验内容 **</h2>
<p>内容 1.1：采用子程序、宏指令、多模块等编程技术设计实现一个较为完整的计算机系统运行状态的监测系统，给出完整的建模描述、方案设计、结果记录与分析。</p>
<p>内容 1.2：初步探索影响设计目标和技术方案的多种因素，主要从指令优化对程序性能的影响，不同的约束条件对程序设计的影响，不同算法的选择对程序与程序结构的影响，不同程序结构对程序设计的影响，不同编程环境的影响等方面进行实践。</p>
<h2 id="13内容11的实验过程"><a class="markdownIt-Anchor" href="#13内容11的实验过程">#</a> <strong>1</strong>**.3**** 内容 1.<strong><strong>1</strong></strong> 的实验过程 **</h2>
<h3 id="131设计思想"><a class="markdownIt-Anchor" href="#131设计思想">#</a> <strong>1</strong>**.3.1**** 设计思想 **</h3>
<p>首先将程序划分为两个模块：主体逻辑模块和用户输入模块。其中主体逻辑模块又包含了下列子功能：字符串比较、计算处理、分组复制、循环打印。其中每个部分的说明如下：</p>
<p><strong>（1）</strong><em><strong>* 主体逻辑部分 *</strong></em></p>
<p>功能：协调控制其它模块的执行，打印提示信息，控制流程。</p>
<p>使用到的寄存器：EAX，EBX，EDI</p>
<p><strong>（2）</strong><em><strong>* 字符串比较部分 *</strong></em></p>
<p>功能：比较两个字符串是否相等。</p>
<p>实现：采用宏定义实现，宏的声明 COMPARESTR MACRO  STR1,STR2,IN1</p>
<p>参数说明：STR1：字符串 1，STR2：字符串 2，INI 计数器</p>
<p>使用到的寄存器：ESI，EDI</p>
<p><strong>（3）</strong><em><strong>* 计算处理部分 *</strong></em></p>
<p>功能：从指定结构体中取出 a，b，c 并计算 f，保存在结构体的相应位置</p>
<p>实现：采用子程序实现，子程序声明 func0_calc proc</p>
<p>参数说明：无</p>
<p>使用到的寄存器：EAX，EBX，EDI</p>
<p><strong>（4）</strong><em><strong>* 分组复制部分 *</strong></em></p>
<p>功能：判断指定结构体中 f 的值并写入相应的缓存区</p>
<p>实现：采用子程序实现，子程序声明 func1_wrtie  proc</p>
<p>参数说明：无</p>
<p>使用到的寄存器：EAX，EBX，ECX，EDI</p>
<p><strong>（5）</strong><em><strong>* 循环打印部分 *</strong></em></p>
<p>功能：打印输出 MIDF 中所有的数据</p>
<p>实现：采用子程序实现，子程序名 func2_print  proc  M : DWORD</p>
<p>参数说明：M：MIDF 缓存区指针 MINDEX 的值，即 MIDF 存放的数据量</p>
<p>使用到的寄存器：EAX，ESI</p>
<p><strong>（6）</strong><em><strong>* 用户输入部分 *</strong></em></p>
<p>功能：等待用户输入，R 表示重新计算和输出，Q 表示退出，其他输入无效</p>
<p>实现：在另一个文件中采用子程序实现，子程序名 func3_input  proc</p>
<p>参数说明：无</p>
<p>使用到的寄存器：EAX</p>
<p>段合并：否</p>
<p><em><strong>* 不同文件之间的公共符号说明如表 1.1 所示：*</strong></em></p>
<p><em><strong>* 表 1.1 公共符号说明 *</strong></em></p>
<table>
<thead>
<tr>
<th><em><strong>* 符号 *</strong></em></th>
<th><em><strong>* 类型 *</strong></em></th>
<th><em><strong>* 内容 *</strong></em></th>
<th><em><strong>* 说明 *</strong></em></th>
</tr>
</thead>
<tbody>
<tr>
<td>NEXTL</td>
<td>byte</td>
<td>0ah,0dh,0</td>
<td>换行符号</td>
</tr>
<tr>
<td>BUF7</td>
<td>byte</td>
<td>‘Input R to restart or Q to quit’,0ah,0dh,0</td>
<td>用户输入的提示信息</td>
</tr>
<tr>
<td>lpFmt</td>
<td>byte</td>
<td>“%s”,0</td>
<td>用于输入输出函数</td>
</tr>
<tr>
<td>INFO0</td>
<td>dword</td>
<td>初始值 0</td>
<td>判断输入内容的变量</td>
</tr>
</tbody>
</table>
<h3 id="132流程图imgfilecusers290123~1appdatalocaltempksohtml22556wps2jpg"><a class="markdownIt-Anchor" href="#132流程图imgfilecusers290123~1appdatalocaltempksohtml22556wps2jpg">#</a> <strong>1</strong>**.3.2**** 流程图 **![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps2.jpg)</h3>
<p><em><strong>* 图 1.1  主程序流程图 *</strong></em></p>
<p>图 1.1 展示了主流程的总体结构。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps3.jpg)</p>
<p><em><strong>* 图 1.2  func0_calc 流程 *</strong></em></p>
<p>图 1.2 展示了计算 f 的流程，具体实现在子函数 func0_calc 中。</p>
<h3 id="133源程序"><a class="markdownIt-Anchor" href="#133源程序">#</a> <strong>1</strong>**.3.3**** 源程序 **</h3>
<p>见电子版文件 “main3_1.asm” 和 “mod1.asm”。</p>
<h3 id="134实验记录与分析"><a class="markdownIt-Anchor" href="#134实验记录与分析">#</a> <strong>1</strong>**.3.4**** 实验记录与分析 **</h3>
<ol>
<li>实验环境条件</li>
</ol>
<p>INTEL 处理器 2.7GHz，8G 内存；WINDOWS10 下 VS2019 社区版。</p>
<ol start="2">
<li>汇编、链接中的情况</li>
</ol>
<p>汇编过程中主要出现了 2 个问题，具体如下：</p>
<p><strong>(1)</strong> <em><strong>* 问题 *</strong></em>：将源程序模块化时，函数声明为 public 报错无法识别函数符号。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps4.jpg)</p>
<p><em><strong>* 图 1.3  mod1 模块中的函数 public 声明 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps5.jpg)</p>
<p><em><strong>* 图 1.4  主模块中的 extern 声明 *</strong></em></p>
<p><em><strong>* 解决方法 *</strong></em>：通过查阅资料得知，新版本 VS2019 的编译器已经不支持函数声明为 public 的语法，需要用 proto 声明，改正后即可正常编译运行。</p>
<p>​       ![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps6.jpg)</p>
<p><em><strong>* 图 1.5  改正后的代码 *</strong></em></p>
<p><strong>(2)</strong> <em><strong>* 问题 *</strong></em>：输入密码使用？初始化，在字符串判断时不正确</p>
<p><em><strong>* 解决方法 *</strong></em>：用调试工具发现？符号不分配空间，仅有结束标记 “.”，读入的字符将后续的字符覆盖。如图 1.6 所示，密码为 123456789，输入 S。S 从 buf3 的首地址存起，表示为 S.，所以将后面存储的 buf3 的 1 覆盖掉了。所以可以使用长度为 9 的任意字符串初始化，获取存储空间。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps7.jpg)</p>
<p><em><strong>* 图 1.6  字符串覆盖 *</strong></em></p>
<ol start="3">
<li>程序基本功能的验证情况</li>
</ol>
<p>运行程序并输入数据进行测试，基本功能均已经实现。</p>
<p>关键功能如下：</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps8.jpg)</p>
<p><em><strong>* 图 1.7  功能测试：登陆失败连续 3 次 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps9.jpg)</p>
<p><em><strong>* 图 1.8  功能测试：登陆成功 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps10.jpg)</p>
<p><em><strong>* 图 1.9  功能测试：打印 MIDF 缓存区和处理用户输入 *</strong></em></p>
<ol start="4">
<li>使用调试工具观察、探究代码的情况</li>
</ol>
<p>利用 VS2019 的设置断点和单步执行的方法，可以观察到子程序中的 ret 语句会返回到调用子程序的语句之后，如图 1.10 和图 1.11 所示。子程序中的局部变量保存在堆栈中，而不是数据段中。在调用子程序时，局部变量的地址是动态分配的，而全局变量的地址是确定不变的。此外，还观察数据存储时，有内存对齐现象，查阅资料可知，内存对齐时运算速度最快，宁可损失一两个字节也要进行对齐，这是一种编译的优化。在传递参数时，一般可以约定一个公共变量，或者使用堆栈压栈的方式传递参数，但如果使用寄存器传递参数需要注意寄存器的值要事先用堆栈保存，调用完毕后从堆栈取出以恢复，否则很容易出错。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps11.jpg)</p>
<p><em><strong>* 图 1.10  子程序返回前的 EIP*</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps12.jpg)</p>
<p><em><strong>* 图 1.11  子程序返回后的 EIP*</strong></em></p>
<p>5. 其他</p>
<p>在模块化时，利用 VS2019 的单步调试观察到 CMP 比较时结果有误。当变量是从另一个文件引用时，发现比较时 KEYIN 值为’Q’，理应发生跳转，但实际上并未发生跳转，如图 1.12 和图 1.13 所示。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps13.jpg)</p>
<p><em><strong>* 图 1.12  比较前一步 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps14.jpg)</p>
<p><em><strong>* 图 1.13  比较后一步 *</strong></em></p>
<p>进一步探究发现，可能是需要刷新标志寄存器，因为 CMP 是根据标志寄存器的值判定的，并不保存两个比较数相减的结果。如果将外部变量 KEYIN 改为该模块中的局部变量，则 CMP 比较结果会正确跳转。</p>
<h2 id="14内容12的实验过程"><a class="markdownIt-Anchor" href="#14内容12的实验过程">#</a> <strong>1</strong>**.4<strong><strong> 内容 1</strong></strong>.2**** 的实验过程 **</h2>
<h3 id="141指令优化对程序的影响"><a class="markdownIt-Anchor" href="#141指令优化对程序的影响">#</a> <strong>1.4.1**** 指令优化对程序的影响</strong></h3>
<p>指令优化的主要思路是减少指令数量，尽量少用乘法和除法，多用寄存器进行运算。</p>
<p>首先选择时间测量的方式：系统中时间戳以 64 位无符号整型数的格式，记录了自 CPU 上电以来所经过的时钟周期数。由于目前的 CPU 主频非常高，这个部件可以达到纳秒级的计时精度。因此选用这种测量方法，涉及到的函数主要为 RDTSC。在实际应用中，由于运行一次程序所用的时间很短，时间戳的高 32 位不会发生变化，只使用低 32 位进行计算即可。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps15.jpg)</p>
<p><em><strong>* 图 1.14  使用 RDTSC 输出时钟周期数示例 *</strong></em></p>
<p>图 1.15 展示了未经过任何优化的程序运行的时钟周期数。在测量时使用尽可能大的循环次数，这里选用写入三种缓存区各 20000 组数据，共 60000 次循环计数。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps16.jpg)</p>
<p><em><strong>* 图 1.15  未经优化的时钟周期数 *</strong></em></p>
<p><em><strong>* 优化方法：*</strong></em></p>
<p><em><strong>*（1）除法 / 128 改为向右移动 7 位 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps17.jpg)</p>
<p><em><strong>* 图 1.16  除法指令优化后的某一次时钟周期数 *</strong></em></p>
<p><strong>（2）</strong><em><strong>* 乘法改为向左移动 2 位，再加上原来的值，避免直接乘法 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps18.jpg)</p>
<p><em><strong>* 图 1.17  乘法指令优化后的某一次时钟周期数 *</strong></em></p>
<p><strong>（3）</strong><em><strong>* 尽量使用寄存器进行运算 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps19.jpg)</p>
<p><em><strong>* 图 1.18  尽量使用寄存器优化后的某一次时钟周期数 *</strong></em></p>
<p><em><strong>* 相关优化的提升幅度如下表所示：*</strong></em></p>
<p><em><strong>* 表 1.2 指令优化的测量数据 *</strong></em></p>
<table>
<thead>
<tr>
<th>优化内容</th>
<th>3 次平均时钟周期数</th>
<th>60000 次循环平均耗时</th>
<th>总提升幅度</th>
</tr>
</thead>
<tbody>
<tr>
<td>未优化</td>
<td>3593451</td>
<td>13.31ms</td>
<td>-</td>
</tr>
<tr>
<td>除法指令优化</td>
<td>2225839</td>
<td>8.24ms</td>
<td>38.1%</td>
</tr>
<tr>
<td>乘法指令优化</td>
<td>1478390</td>
<td>5.48ms</td>
<td>58.8%</td>
</tr>
<tr>
<td>寄存器使用优化</td>
<td>1231675</td>
<td>4.56ms</td>
<td>65.7%</td>
</tr>
</tbody>
</table>
<p>优化后最终每次循环的平均耗时为 1231675/60000/2.7Ghz=0.076 微秒。相比未优化提升了 65.7%。由此可见，指令的优化可以显著提升程序的运行速度。</p>
<h3 id="142约束条件-算法与程序结构的影响"><a class="markdownIt-Anchor" href="#142约束条件-算法与程序结构的影响">#</a> <strong>1.4.2**** 约束条件、算法与程序结构的影响</strong></h3>
<p>在本实验涉及的算法中，除了乘除法替换成移位之外，主要就是字符串的匹配。但是字符串匹配问题很容易做到 O (n) 的最低时间复杂度了，因此算法的优化体现不明显。但是在用结构体表示和直接用变量表示这样两种不同的数据结构上还会存在一些速度上的区别，结构体会稍慢一些。</p>
<p>本次实验中程序结构的调整主要体现在使程序模块化，每个子程序负责自己的功能，在出错时可以快速定位错误并修改。而在后续需求变化时，也能方便地调整子程序，而不用较大篇幅的修改。并且子程序的调用等过程也尽量减少了耦合，尽量避免了子程序之间的依赖关系。在本实验中程序结构的调整对运算速度影响不大，因为子程序和宏只是将代码分区，并没有减少实际指令条数。</p>
<h3 id="143编程环境的影响"><a class="markdownIt-Anchor" href="#143编程环境的影响">#</a> <strong>1.4.3**** 编程环境的影响</strong></h3>
<p>本程序除了在 Windows 环境下测试，还尝试在 Ubuntu 环境下运行了。</p>
<p>在 Windows 环境下优化后的程序 60000 次循环平均耗时 4.56ms，而 Ubuntu 环境下平均耗时长达 11.69ms，比 Windows 慢很多。初步猜测是由于 Ubuntu 环境的系统内存只有 2GB，与 Windows 环境下的 16GB 内存相差很大，并且虚拟机运行时性能得不到充分释放导致的。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps20.jpg)</p>
<p><em><strong>* 图 1.19  Ubuntu 环境下运行的某一次时钟周期数 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps21.jpg)</p>
<p><em><strong>* 图 1.20  Ubuntu 系统的配置参数 *</strong></em></p>
<p>在 QEMU 环境中运行程序就比较繁琐了。QEMU 是纯命令行模式，输入输出都要仔细核对，很容易出错，写代码的界面也不能复制和粘贴。要在 Windows 和 QEMU 中拷贝文件很麻烦，因此选用了简单的内存拷贝程序记录运行时间。优化前的内存拷贝是将长度为 60000000 的字符数组复制到另一片内存中，耗时约 202ms，进行循环展开和内存突发传输方式优化后，耗时约 54ms。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps22.jpg)</p>
<p><em><strong>* 图 1.21  优化前的内存拷贝用时 *</strong></em></p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps23.jpg)</p>
<p><em><strong>* 图 1.22  优化后的内存拷贝用时 *</strong></em></p>
<p>QEMU 环境 ARMv8 架构相比 80x86 的主要特点如下：</p>
<p>（1）16 个寄存器名为 R0-R15，与 x86 不同。</p>
<p>（2）指令语句格式不同：如直接寻址 mov R1，#2，将 2 放入 R1 寄存器；指令 LDR R0,[R3, #5] 是将 R3 的值 + 5 再放入 R0 寄存器中，这些均与 x86 寻址的指令格式不同。</p>
<p>（3）子程序调用的参数传递与返回方法：主函数与子函数间的入口参数通过寄存器 R0-R3 四个寄存器传递，如果有更多的参数，则通过堆栈传递。主函数返回值放在 R0 寄存器中。R13 寄存器是堆栈寄存器，用来保存堆栈的当前指针。R14 寄存器是链接寄存器，用来保存函数的返回地址。R15 寄存器是程序寄存器，指向程序当前的地址。</p>
<p>（4）c 语言混合编程时汇编程序与 c 程序在两个文件中，作为两个函数模块存在，编译连接有所不同，如图 1.23 所示。而 x86 是 c 程序代码中嵌套汇编代码。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps24.jpg)</p>
<p><em><strong>* 图 1.23  QEMU 环境下编译连接的过程 *</strong></em></p>
<p>在 64 位环境中，与本次运行的 32 位环境又有所不同，观察调试给定的 64 位程序，得出主要特点如下：</p>
<p>（1）寄存器数据增加，变为 16 个。</p>
<p>（2）64 位寄存器以 r 开头，比如 rsp 是指向栈顶的指针的寄存器。</p>
<p>（3）64 位中新增了一些指令，如 movabsq。</p>
<p>（4）很多情况下不再需要栈帧，寄存器已经足够存储参数。</p>
<p>（5）在给定程序的参数传递时使用堆栈传递。</p>
<p>（6）调用函数时，堆栈的变化总体与 x86 类似。RSP 为栈顶指针，rsp 往下 2 到 10 位记录是返回地址，程序中两个操作数是 [rsp+10] 和 [rsp+12]。图 1.24 中 00007FF745021031 是返回地址，由于内存对齐，前面空了两位，第 rsp+10 位开始是参数。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps25.jpg)</p>
<p><em><strong>* 图 1.24  给定 64 位程序运行时的堆栈 *</strong></em></p>
<h1 id="二-利用汇编语言特点的实验"><a class="markdownIt-Anchor" href="#二-利用汇编语言特点的实验">#</a> <strong>二、利用汇编语言特点的实验</strong></h1>
<h2 id="21目的与要求"><a class="markdownIt-Anchor" href="#21目的与要求">#</a> <strong>2</strong>**.1**** 目的与要求 **</h2>
<p>掌握编写、调试汇编语言程序的基本方法与技术，能根据实验任务要求，设计出较充分利用了汇编语言优势的软件功能部件或软件系统。</p>
<h2 id="22实验内容"><a class="markdownIt-Anchor" href="#22实验内容">#</a> <strong>2</strong>**.2**** 实验内容 **</h2>
<p>在编写的程序中，通过加入内存操控，反跟踪，中断处理，指令优化，程序结构调整等实践内容，达到特殊的效果。</p>
<h2 id="23实验过程"><a class="markdownIt-Anchor" href="#23实验过程">#</a> <strong>2</strong>**.3**** 实验过程 **</h2>
<h3 id="231中断处理程序"><a class="markdownIt-Anchor" href="#231中断处理程序">#</a> <strong>2.3.1**** 中断处理程序</strong></h3>
<p><em><strong>*1.*</strong></em><em><strong>* 设计思想与实验方法 *</strong></em></p>
<p>主要设计思想是先编写中断处理程序，然后在 DOSBOX 环境下安装并可以驻留退出。其中时间读取可以用 I/O 端口 70H 和 71H 直接读取时钟时间和系统配置接口芯片的内容。而 CPU 只能读取 71H 端口的数据，因此可以将 70H 端口设置为要读取的单元，完成切换操作。</p>
<p>查阅资料可知，信息的存放地址为：“时” 偏移值为 4，“分” 偏移值为 2，“秒” 偏移值为 0。基于此，不难得出关键代码如下：</p>
<pre><code class="language-assembly">  MOV AL,4   ;将偏移地址输入AL

  OUT 70H,AL  ;设置访问数据位置

  JMP $+2   ;延时操作，防止端口响应较慢导致结果错误

  IN AL,71H  ;读取数据
</code></pre>
<p>中断流程主要是：先保存原有中断矢量，然后调用原来 8 号中断处理程序的功能，接着进行计数，当计数器从 18 减到 0 时中断返回，同时计数器赋值 18，以此循环。计数器为 0 后进行一次时间读取操作获取当前时间并转换为 ASCII 码调用 10 号中断显示信息然后中断返回。只有当用户输入 q 后才退出程序，同时恢复原来中断的矢量。</p>
<p>任务中要求中断处理程序只能安装一次，需要在安装前进行检查。因为中断驻留程序执行后再卸载后才可正常返回到 DOS。若驻留多次，则需要卸载对应次数才可以正常回到 DOS。</p>
<p>对于该程序，可以采用 DOSBOX 下的 TD 指令直接观察中断矢量表的内容和调试程序。DOSBOX 中调试程序的界面有一定的图形化配置，基本与 VS2019 相同，在内存区直接输入中断矢量的地址就可以看到内容。而读取 CMOS 内容的任务已经蕴含在时间信息获取中了。</p>
<p><em><strong>*2.*</strong></em><em><strong>* 记录与分析 *</strong></em></p>
<p>使用 TD 调试观察中断矢量十分简单，例如想要观察 21 号中断矢量，要在内存区跳转到 0000:0084 处，观察到中断矢量的值为：055300CA。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps26.jpg)</p>
<p><em><strong>* 图 2.1  21 号中断矢量 *</strong></em></p>
<p>在此界面中设置断点单步执行就可以调试程序，不过由于不断获取时钟信息和显示是一个 “死循环”，所以会在某一语句处发生中断然后跳转回去并重复出现此过程。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps27.jpg)</p>
<p><em><strong>* 图 2.2  调试中断处理程序 *</strong></em></p>
<p>调试过程中驻留退出，右上角仍有时钟显示，再次单步执行后回到原有界面，如图 2.3 所示。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps28.jpg)</p>
<p><em><strong>* 图 2.3  调试中断处理程序 *</strong></em></p>
<p>值得一提的是，老式的环境中需要使用 INT 21H 中断来获取字符输入和输出，这与之前所使用的调用 c 语言 scanf、printf 函数不同。因此，该程序的中断使用非常频繁，产生中断的时候是无法在调试界面的，也就是说不能看到内存实时的变化。</p>
<h3 id="232反跟踪程序"><a class="markdownIt-Anchor" href="#232反跟踪程序">#</a> <strong>2.3.2**** 反跟踪程序</strong></h3>
<p><em><strong>*1.*</strong></em><em><strong>* 设计思想与实验方法 *</strong></em></p>
<p>本次实验中主要用到了以下几种反跟踪方法：</p>
<p>（1）将用户名和密码的字符串加密</p>
<p>如图 2.4 所示，将用户名和密码都异或上‘Z’，不在程序中显示明文，增加在内存区域查看字符串直接破解密码的难度。加密后相关字符串比较函数需要重写，中途再次异或上‘Z’，就可以正确比较，但异或指令可能会被跟踪者发现。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps29.jpg)</p>
<p><em><strong>* 图 2.4  字符串加密 *</strong></em></p>
<p>（2）插入无关代码</p>
<p>如图 2.5 所示，计算 f 的流程中最后两步分别是 + 100 和 / 128，考虑在 + 100 的流程中假装加 90，实际上没有保存，真正的结果在上一步就保存在 ECX 寄存器中，然后混合在 / 128 的流程中进行，扰乱视线。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps30.jpg)</p>
<p><em><strong>* 图 2.5  插入无关代码 *</strong></em></p>
<p>（3）增加冗余信息</p>
<p>如图 2.6 所示，在数据定义时增加冗余定义，并在代码段有意使用，在核心操作中随意穿插这些冗余信息，扰乱视线。增加了输入输出的提示信息可能会导致跟踪者误判，例如在输入数字时假装使用字符串的提示信息等。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps31.jpg)</p>
<p><em><strong>* 图 2.6  增加冗余信息 *</strong></em></p>
<p>（4）使用动态跳转间接转移</p>
<p>如图 2.7 所示，将要跳转的标记动态保存到 EBX 寄存器中，通过程序代码无法直接定位到跳转地点。也可以将程序使用到的标号都存在一个表中，跳转时直接使用表中的偏移地址跳转。“动态” 修改代码可以使用加壳工具，但较为繁琐，本程序使用的是地址表间接转移。动态跳转如果和检查中断矢量一起使用，会有很好的效果。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps32.jpg)</p>
<p><em><strong>* 图 2.7  动态跳转 *</strong></em></p>
<p>（5）检查中断矢量表抵制动态调试跟踪</p>
<p>动态调试工具会接管系统原来的单步中断和断点中断的中断服务程序，对应 1 号和 3 号中断。程序通过检查 1 号中断和 3 号中断就可以得知是否被调试跟踪。所以在本程序中直接修改 1 号和 3 号中断矢量的值，将旧值保存，这样在调试的时候单步中断和断点中断都会卡死或者直接退出，达到反跟踪的目的。如图 2.8 所示，就是修改 1 号和 3 号中断矢量的代码。正常运行完程序后再恢复原有中断矢量即可。不过如果修改中断矢量的代码过于明显，可以将反跟踪代码用 nop 替换，这是一大缺陷。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps33.jpg)</p>
<p><em><strong>* 图 2.8  修改中断矢量 *</strong></em></p>
<p><strong>2.</strong> <em><strong>* 反跟踪效果的验证 *</strong></em></p>
<p>静态反汇编后的数据段如图 2.9 所示，其中用户名和密码均加密，无法直接获取。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps34.jpg)</p>
<p><em><strong>* 图 2.9  静态反汇编后的用户名和密码 *</strong></em></p>
<p>如图 2.10 所示，在原有代码设置动态跳转的位置，已经不能直接看出跳转编号，无法得知具体跳转地点，起到反跟踪作用。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps35.jpg)</p>
<p><em><strong>* 图 2.10  动态跳转验证 *</strong></em></p>
<p>如图 2.11 所示，调试时使用断点和单步执行，程序运行后黑屏卡死，说明修改的中断矢量有效果，无法进行实际的调试，起到了反跟踪的作用。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps36.jpg)</p>
<p><em><strong>* 图 2.11  中断矢量验证 *</strong></em></p>
<p><strong>3.</strong> <em><strong>* 跟踪与破解程序 *</strong></em></p>
<p>首先在 IDA 中根据 NAME 字段查找可能作为用户名和密码的字段，如图 2.12 所示。该区域可显示所有人为定义的有含义的符号名称，根据名称可以初步猜测用途。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps37.jpg)</p>
<p><em><strong>* 图 2.12  寻找字段名 *</strong></em></p>
<p>然后定位到用户名和密码处，发现进行了加密，如图 2.13 所示。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps38.jpg)</p>
<p><em><strong>* 图 2.13  寻找用户名密码位置 *</strong></em></p>
<p>可以从关系图中查找，直到找到了某一个字符串比较的逻辑，且传入的参数就是字段名中的两个字符串。接着可以看到里面有异或操作，猜测密码进行了异或，且进行异或的值为 5AH。</p>
<p>![img](file:///C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps39.jpg)</p>
<p><em><strong>* 图 2.14  字符串比较逻辑 *</strong></em></p>
<p>将用户名和密码的密文再次与 5AH 异或，得到原始字符串。但是需要注意的是，IDA 中直接显示的加密后的字符串会缺少头部的一位，可能是识别上有错误，可能需要到相应地址的内存区查找。破解的程序没有包含中断矢量修改的情况，如果有，则需要找到 cli 和 sti，找到有修改中断矢量的代码段，将其修改为 NOP 就可以继续运行。最终得到用户名和密码后再次运行程序即可成功登录，完成破解。</p>
<h3 id="233指令优化及程序结构"><a class="markdownIt-Anchor" href="#233指令优化及程序结构">#</a> <strong>2.3.3**** 指令优化及程序结构</strong></h3>
<p><em><strong>*1.*</strong></em><em><strong>* 实验方法 *</strong></em></p>
<p>实验 2 和 3 的指令优化基本与 1.4 节相同，充分运用了寄存器存取和位运算，几乎没有优化空间了。实验 5 的指令优化主要为循环展开优化和内存突发传输方式优化。</p>
<p>循环展开优化的主要思路是减少指令条数，特别是循环内部指令的数量。例如从原来一次循环执行一次读取和写入变为多次读取和写入，速度会有较大提升。</p>
<p>内存突发传输优化是使用 ldp 和 stp 指令一次操作 16 个字节的数据，理论依据是内存在连续读写多个数据时，性能要优于非连续读写数据。实验结果表明一次读取 16 个字节要显著优于读取 1 个字节，并且速度提升幅度比循环展开更大。</p>
<p><em><strong>* 表 2.1 内存拷贝程序指令优化的测量数据 *</strong></em></p>
<table>
<thead>
<tr>
<th>优化内容</th>
<th>平均耗时</th>
<th>总提升幅度</th>
</tr>
</thead>
<tbody>
<tr>
<td>未优化</td>
<td>204.46ms</td>
<td>-</td>
</tr>
<tr>
<td>循环展开优化</td>
<td>142.97ms</td>
<td>30.1%</td>
</tr>
<tr>
<td>内存突发传输优化</td>
<td>53.52ms</td>
<td>73.8%</td>
</tr>
</tbody>
</table>
<p><em><strong>*2.*</strong></em><em><strong>* 特定指令及程序结构的效果 *</strong></em></p>
<p>汇编语言的特点是偏向底层，直接操控寄存器和内存。实验 3 中 c 语言嵌套汇编语言代码是个很好的例子。c 语言编程时不用关注寄存器的分配和保护，而嵌套的汇编代码段在开始时就要保护寄存器，将上下文使用到的寄存器入栈，否则程序功能会出错。此外，汇编程序结构上层次分明，代码段、数据段和堆栈段的定义流程化，而 c 语言不需要显示地定义堆栈，会在编译时自动进行堆栈操作。</p>
<p>因此，汇编语言有较大的灵活性，对于内存、寄存器和堆栈有较强的可操作性，运用得当可以使程序运行速度更快，减少不必要的操作。</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-06-07 11:05:00" itemprop="dateModified" datetime="2023-06-07T11:05:00+08:00">2023-06-07</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>dodobird <i class="ic i-at"><em>@</em></i>呆呆鸟のBlog
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://dodobird.top/2023/05/11/assembly/" title="汇编语言实验">http://dodobird.top/2023/05/11/assembly/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2019/07/25/code-highlight/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;dodobird-blog.oss-cn-shanghai.aliyuncs.com&#x2F;2056632.jpg" title="Code Highlight Style test">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Code Highlight Style test</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/05/24/hello-world/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;dodobird-blog.oss-cn-shanghai.aliyuncs.com&#x2F;2055991.jpg" title="Hello World">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Hello World</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%A8%E7%A8%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text"> 一、程序设计的全程实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E7%9B%AE%E7%9A%84%E4%B8%8E%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text"> 1**.1**** 目的与要求 **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text"> 1**.2**** 实验内容 **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%86%85%E5%AE%B911%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text"> 1**.3**** 内容 1.1 的实验过程 **</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#131%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 1**.3.1**** 设计思想 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132%E6%B5%81%E7%A8%8B%E5%9B%BEimgfilecusers290123~1appdatalocaltempksohtml22556wps2jpg"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 1**.3.2**** 流程图 **![img](file:&#x2F;&#x2F;&#x2F;C:\Users\290123~1\AppData\Local\Temp\ksohtml22556\wps2.jpg)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 1**.3.3**** 源程序 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 1**.3.4**** 实验记录与分析 **</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E5%86%85%E5%AE%B912%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text"> 1**.4 内容 1.2**** 的实验过程 **</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#141%E6%8C%87%E4%BB%A4%E4%BC%98%E5%8C%96%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 1.4.1**** 指令优化对程序的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6-%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 1.4.2**** 约束条件、算法与程序结构的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#143%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 1.4.3**** 编程环境的影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9%E7%9A%84%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text"> 二、利用汇编语言特点的实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E7%9B%AE%E7%9A%84%E4%B8%8E%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text"> 2**.1**** 目的与要求 **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.</span> <span class="toc-text"> 2**.2**** 实验内容 **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> 2**.3**** 实验过程 **</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 2.3.1**** 中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232%E5%8F%8D%E8%B7%9F%E8%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 2.3.2**** 反跟踪程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233%E6%8C%87%E4%BB%A4%E4%BC%98%E5%8C%96%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 2.3.3**** 指令优化及程序结构</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="dodobird"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">dodobird</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">4</span>
        <span class="name">文章</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZG9iaXJkMjMz" title="https:&#x2F;&#x2F;github.com&#x2F;dodobird233"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS8=" title="https:&#x2F;&#x2F;twitter.com&#x2F;"><i class="ic i-twitter"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvZG9iaXJkMjMz" title="https:&#x2F;&#x2F;github.com&#x2F;dodobird233"><i class="ic i-address-card"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOm1hcmlvaG9uZzEyOEBvdXRsb29rLmNvbQ==" title="mailto:mariohong128@outlook.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2019/07/25/code-highlight/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/05/24/hello-world/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/05/11/assembly/" title="汇编语言实验">汇编语言实验</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/05/24/hello-world/" title="Hello World">Hello World</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2013/12/24/elements/" title="Elements">Elements</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2019/07/25/code-highlight/" title="Code Highlight Style test">Code Highlight Style test</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2021 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">dodobird @ DodoBird's Blog</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/05/11/assembly/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
